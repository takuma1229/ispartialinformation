
/content/drive/MyDrive/research_discourse_relation/discourse_relation_explainability
/usr/local/lib/python3.10/dist-packages/huggingface_hub/utils/_token.py:88: UserWarning:
The secret `HF_TOKEN` does not exist in your Colab secrets.
To authenticate with the Hugging Face Hub, create a token in your settings tab (https://huggingface.co/settings/tokens), set it as secret in your Google Colab and restart your session.
You will be able to reuse this secret in all of your notebooks.
Please note that authentication is recommended but still optional to access public models or datasets.
  warnings.warn(
num_added_tokens: 16, added_special_tokens: <NOUN>,<PRONOUN>,<ADJECTIVAL-NOUN>,<PRENOUN-ADJECTIVAL>,<ADVERB>,<CONJUNCTION>,<INTERJECTION>,<VERB>,<ADJECTIVE>,<AUXILIARY-VERB>,<PARTICLE>,<PREFIX>,<SUFFIX>,<SYMBOL>,<AUXILIARY-SYMBOL>,<BLANK>
Some weights of BertForSequenceClassification were not initialized from the model checkpoint at cl-tohoku/bert-base-japanese-v3 and are newly initialized: ['classifier.bias', 'classifier.weight']
You should probably TRAIN this model on a down-stream task to be able to use it for predictions and inference.
/usr/lib/python3.10/multiprocessing/popen_fork.py:66: RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.
  self.pid = os.fork()




  0%|          | 0/15 [00:00<?, ?it/s]/usr/lib/python3.10/multiprocessing/popen_fork.py:66: RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.
  self.pid = os.fork()[00:00<?, ?it/s]
epoch: None 	loss: 0.065226   	accuracy: 0.2575 	precision: 0.1848 	recall: 0.2304 	f1: 0.1233




  self.pid = os.fork()[00:00<?, ?it/s]

  self.pid = os.fork()[00:00<?, ?it/s]
epoch: 0 	loss: 0.004158   	accuracy: 0.7506 	precision: 0.1501 	recall: 0.2000 	f1: 0.1715
epoch: 0 	loss: 0.027549   	accuracy: 0.7186 	precision: 0.1437 	recall: 0.2000 	f1: 0.1672
  7%|▋         | 1/15 [01:41<23:34, 10/usr/lib/python3.10/multiprocessing/popen_fork.py:66: RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.
  self.pid = os.fork()[00:00<?, ?it/s]






  self.pid = os.fork()[00:00<?, ?it/s]
 13%|█▎        | 2/15 [01:55<10:51, 50/usr/lib/python3.10/multiprocessing/popen_fork.py:66: RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.
  self.pid = os.fork()[00:00<?, ?it/s]
  5%|▍         | 4/84 [00:00<00:12,  6.46it/s]
epoch: 1 	loss: 0.003556   	accuracy: 0.7506 	precision: 0.1501 	recall: 0.2000 	f1: 0.1715






  self.pid = os.fork()[00:00<?, ?it/s]
 20%|██        | 3/15 [02:10<06:47, 33/usr/lib/python3.10/multiprocessing/popen_fork.py:66: RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.
  self.pid = os.fork()[00:00<?, ?it/s]
epoch: 2 	loss: 0.003275   	accuracy: 0.7506 	precision: 0.1501 	recall: 0.2000 	f1: 0.1715
epoch: 2 	loss: 0.029242   	accuracy: 0.7186 	precision: 0.1437 	recall: 0.2000 	f1: 0.1672






  self.pid = os.fork()[00:00<?, ?it/s]
epoch: 3 	loss: 0.003230   	accuracy: 0.7506 	precision: 0.1501 	recall: 0.2000 	f1: 0.1715
epoch: 3 	loss: 0.029669   	accuracy: 0.7186 	precision: 0.1437 	recall: 0.2000 	f1: 0.1672
 27%|██▋       | 4/15 [02:24<04:49, 26/usr/lib/python3.10/multiprocessing/popen_fork.py:66: RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.
  self.pid = os.fork()[00:00<?, ?it/s]






  self.pid = os.fork()[00:00<?, ?it/s]
 33%|███▎      | 5/15 [02:39<03:40, 22/usr/lib/python3.10/multiprocessing/popen_fork.py:66: RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.
  self.pid = os.fork()[00:00<?, ?it/s]
  6%|▌         | 5/84 [00:00<00:12,  6.54it/s]
epoch: 4 	loss: 0.003179   	accuracy: 0.7506 	precision: 0.1501 	recall: 0.2000 	f1: 0.1715






  self.pid = os.fork()[00:00<?, ?it/s]
 40%|████      | 6/15 [02:53<02:55, 19/usr/lib/python3.10/multiprocessing/popen_fork.py:66: RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.
  self.pid = os.fork()[00:00<?, ?it/s]
  4%|▎         | 3/84 [00:00<00:13,  6.15it/s]
epoch: 5 	loss: 0.003166   	accuracy: 0.7506 	precision: 0.1501 	recall: 0.2000 	f1: 0.1715






  self.pid = os.fork()[00:00<?, ?it/s]
 47%|████▋     | 7/15 [03:08<02:22, 17/usr/lib/python3.10/multiprocessing/popen_fork.py:66: RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.
  self.pid = os.fork()[00:00<?, ?it/s]
epoch: 6 	loss: 0.003210   	accuracy: 0.7506 	precision: 0.1501 	recall: 0.2000 	f1: 0.1715
epoch: 6 	loss: 0.029924   	accuracy: 0.7186 	precision: 0.1437 	recall: 0.2000 	f1: 0.1672





  self.pid = os.fork()[00:00<?, ?it/s]
  9%|▉         | 1/11 [00:00<00:02,  4.70it/s]
epoch: 7 	loss: 0.003223   	accuracy: 0.7506 	precision: 0.1501 	recall: 0.2000 	f1: 0.1715
  self.pid = os.fork()[00:00<?, ?it/s]






  self.pid = os.fork()[00:00<?, ?it/s]
 60%|██████    | 9/15 [03:37<01:36, 16/usr/lib/python3.10/multiprocessing/popen_fork.py:66: RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.
  self.pid = os.fork()[00:00<?, ?it/s]
  8%|▊         | 7/84 [00:01<00:10,  7.46it/s]
epoch: 8 	loss: 0.003230   	accuracy: 0.7506 	precision: 0.1501 	recall: 0.2000 	f1: 0.1715






  self.pid = os.fork()[00:00<?, ?it/s]
 67%|██████▋   | 10/15 [03:51<01:17, 1/usr/lib/python3.10/multiprocessing/popen_fork.py:66: RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.
  self.pid = os.fork()[00:00<?, ?it/s]
  5%|▍         | 4/84 [00:00<00:12,  6.55it/s]
epoch: 9 	loss: 0.003189   	accuracy: 0.7506 	precision: 0.1501 	recall: 0.2000 	f1: 0.1715






  self.pid = os.fork()[00:00<?, ?it/s]
 73%|███████▎  | 11/15 [04:06<01:01, 1/usr/lib/python3.10/multiprocessing/popen_fork.py:66: RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.
  self.pid = os.fork()[00:00<?, ?it/s]
epoch: 10 	loss: 0.003218   	accuracy: 0.7506 	precision: 0.1501 	recall: 0.2000 	f1: 0.1715
epoch: 10 	loss: 0.030450   	accuracy: 0.7186 	precision: 0.1437 	recall: 0.2000 	f1: 0.1672





  self.pid = os.fork()[00:00<?, ?it/s]
 45%|████▌     | 5/11 [00:00<00:00, 18.21it/s]
epoch: 11 	loss: 0.003309   	accuracy: 0.7506 	precision: 0.1501 	recall: 0.2000 	f1: 0.1715
  self.pid = os.fork()[00:00<?, ?it/s]






  self.pid = os.fork()[00:00<?, ?it/s]
 87%|████████▋ | 13/15 [04:35<00:29, 1/usr/lib/python3.10/multiprocessing/popen_fork.py:66: RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.
  self.pid = os.fork()[00:00<?, ?it/s]
 10%|▉         | 8/84 [00:01<00:12,  5.92it/s]
epoch: 12 	loss: 0.003401   	accuracy: 0.7506 	precision: 0.1501 	recall: 0.2000 	f1: 0.1715






  self.pid = os.fork()[00:00<?, ?it/s]
 93%|█████████▎| 14/15 [04:49<00:14, 1/usr/lib/python3.10/multiprocessing/popen_fork.py:66: RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.
  self.pid = os.fork()[00:00<?, ?it/s]
  6%|▌         | 5/84 [00:00<00:12,  6.55it/s]
epoch: 13 	loss: 0.003417   	accuracy: 0.7506 	precision: 0.1501 	recall: 0.2000 	f1: 0.1715






  self.pid = os.fork()[00:00<?, ?it/s]
100%|██████████| 15/15 [05:04<00:00, 20.29s/it]
  0%|          | 0/11 [00:00<?, ?it/s]/usr/lib/python3.10/multiprocessing/popen_fork.py:66: RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.
  self.pid = os.fork()
 45%|████▌     | 5/11 [00:00<00:00, 17.97it/s]
epoch: 14 	loss: 0.003490   	accuracy: 0.7506 	precision: 0.1501 	recall: 0.2000 	f1: 0.1715
  0%|          | 0/11 [00:00<?, ?it/s]/usr/lib/python3.10/multiprocessing/popen_fork.py:66: RuntimeWarning: os.fork() was called. os.fork() is incompatible with multithreaded code, and JAX is multithreaded, so this will likely lead to a deadlock.
  self.pid = os.fork()
/usr/local/lib/python3.10/dist-packages/sklearn/metrics/_classification.py:1344: UndefinedMetricWarning: Precision and F-score are ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, msg_start, len(result))
/usr/local/lib/python3.10/dist-packages/sklearn/metrics/_classification.py:1344: UndefinedMetricWarning: Precision and F-score are ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, msg_start, len(result))
/usr/local/lib/python3.10/dist-packages/sklearn/metrics/_classification.py:1344: UndefinedMetricWarning: Precision and F-score are ill-defined and being set to 0.0 in labels with no predicted samples. Use `zero_division` parameter to control this behavior.
  _warn_prf(average, modifier, msg_start, len(result))
No traceback available to show.
{'best-epoch': 0, 'loss': 0.03816290128798712, 'accuracy': 0.6607142857142857, 'precision': 0.13214285714285715, 'recall': 0.2, 'f1': 0.15913978494623657}
OptimizedModule(
  (_orig_mod): BertForSequenceClassification(
    (bert): BertModel(
      (embeddings): BertEmbeddings(
        (word_embeddings): Embedding(32784, 768)
        (position_embeddings): Embedding(512, 768)
        (token_type_embeddings): Embedding(2, 768)
        (LayerNorm): LayerNorm((768,), eps=1e-12, elementwise_affine=True)
        (dropout): Dropout(p=0.1, inplace=False)
      )
      (encoder): BertEncoder(
        (layer): ModuleList(
          (0-11): 12 x BertLayer(
            (attention): BertAttention(
              (self): BertSelfAttention(
                (query): Linear(in_features=768, out_features=768, bias=True)
                (key): Linear(in_features=768, out_features=768, bias=True)
                (value): Linear(in_features=768, out_features=768, bias=True)
                (dropout): Dropout(p=0.1, inplace=False)
              )
              (output): BertSelfOutput(
                (dense): Linear(in_features=768, out_features=768, bias=True)
                (LayerNorm): LayerNorm((768,), eps=1e-12, elementwise_affine=True)
                (dropout): Dropout(p=0.1, inplace=False)
              )
            )
            (intermediate): BertIntermediate(
              (dense): Linear(in_features=768, out_features=3072, bias=True)
              (intermediate_act_fn): GELUActivation()
            )
            (output): BertOutput(
              (dense): Linear(in_features=3072, out_features=768, bias=True)
              (LayerNorm): LayerNorm((768,), eps=1e-12, elementwise_affine=True)
              (dropout): Dropout(p=0.1, inplace=False)
            )
          )
        )
      )
      (pooler): BertPooler(
        (dense): Linear(in_features=768, out_features=768, bias=True)
        (activation): Tanh()
      )
    )
    (dropout): Dropout(p=0.1, inplace=False)
    (classifier): Linear(in_features=768, out_features=5, bias=True)
  )
)
<class 'torch._dynamo.eval_frame.OptimizedModule'>
<class 'transformers.models.bert.modeling_bert.BertForSequenceClassification'>